Okay, looks good. Another project we did as TypeFirst was Oralynx. Oralynx is a network, a dentistry specialist kind of network, professional network, and consumer portal. It helps consumers to find different types of practices, and it provides referrals internally within the network. It has the legal architecture built in on the legal side of the company, where they understand the steps and guardrails involved with information disclosure, so they can help facilitate that for clients looking to find a suitable specialist or a suitable service provider covered by their insurance from one to the other, and have the types of reviews, a review system as well, so you can find whatever. So here, it wasn't a big development job. It was similar to Connexus, where this was a technical audit and documentation planning engagement, like a true consultancy engagement. So here, they were working with Azure, but they knew that this was a startup that had been purchased and was trying to grow to the big leagues, and they were still saddled with siloed knowledge and lack of documentation, lack of ability to grow the team and the team's operations. They would have one or two people that they needed, even though they weren't very experienced, or it wasn't somebody of the seniority level that maybe you would need to grow to a certain place. They had received some funding, and they wanted to increase their manpower, but were constrained at having one person be the leader of a technical team, while also they were kind of needed to take care of the everyday operations and development. And they knew that they had to scale out and improve their DevOps and their infrastructure a bit. They had performance issues that were a result of the increased traffic, and they definitely had no visibility, no observability into much. They always had to go through this one guy that knew where stuff was or where to look. It was also difficult to onboard people or to get them to a productive state, because they just were fully dependent on this one or two guys. So they needed documentation that was strong and useful, and provided them a view of where the system was at, what a new person would have to learn, and what they would have to know to go, what hurdles they might watch out for, resolutions, things, considerations, and also architectural plans and technical debt overviews to say like, okay, this part is good. This is an example to follow. This is not. This is just legacy and a plan for new features going here. We're moving towards this direction. This is deprecated, helping some crucial pain points like front-facing loading times. This was an issue with the client, and it was getting too much data in an inefficient way because it had grown too much. So they needed help resolving some core critical technical issues that were larger. You need a more senior person to do so properly. And also the other guys were filled to the brim with tickets already. And to have discussions from a higher level representing the technical side on how to properly grow and adjust the platform to fit the needs of the growing company. They had feature requests. They had things that they wanted to ensure. They had safety and legal constraints. And they needed to do all this. Some of these were not like an urgent thing, but they needed this to be discussed in light of what the company's business needs were. And they needed a good translator for this that could give them the precise reasoning and that they could verify with other experts hired for very short periods of time or their investors' technical hands to say, yes, this is the right to say, yes, this makes sense, what he's saying. It's backed up by solid specifics. And it has strong evidentiary basis. And that would make them feel comfortable because they felt like the guys that they had, as I said, they weren't like all that senior. And they felt like they couldn't, they didn't get the confidence from these kind of conversations with them that they would rather just be heads down working and left them wondering how stuff would develop. So this was a three-month in and out thing. It was good. Well, we shouldn't even mention the time, I think. But yeah, like a three-month engagement. Let's see. No, it was more like four. And the output was fixing these. So this is a React and Node full stack thing. But there were legacy Golang things, which they were moving away from, but that were still necessary to consider as part of the overall picture. This was on Azure. They were on Kubernetes. And they had almost no DevOps to speak of. I mean, they had some GitHub actions, but they deployed stuff manually, controlled the cluster manually. I helped them to tie in a branching system on Kubernetes, leaving the actual production deployments manual. But before, they didn't have a good way to test new features. It will be all local until game time, which made everybody very nervous. This is a high importance ticket. So using GitHub actions and the Azure Kubernetes services, set up branching, and I fixed the loading time. So I moved the code to a gzip CDN feed. So I added that to the CI and just explained to them how the front end should be deployed. I mean, they already had a front end service, which was just serving files. But, yes, this was in Next.js, as were all of, also, Kinectsys, and also the sector growth integrations. The sector growth integrations were all GraphQL-based, by the way. So was Auralinks. They used Postgres. So for improving the response time slash latency of the Auralink site, it was a matter of sorry, no, the CDN thing. Yes, the CDN thing was real at first. I think I might be getting confused, actually. Forget the CDN thing. It was about utilizing, better utilizing the—so there was a lot of islands. I mean, there was a lot of stuff that was—that's what I'm trying to say. Like, all these companies—sorry, the Connexus and Auralink, which are both companies that was brought in to consult, were using Next, but they weren't using it to its full potential. So there were things that you could strategically move to server-side data fetching. That was a better idea. Also, there was data that you could progressively reveal things in a better way using islands. Also, I added a service, a data service, because different islands would be getting the same data, and I could trigger the service to fetch everything with less requests and all kind of asynchronously firing as soon as the JavaScript mounted, rather than kind of wait for one island, one thing to load, for example, the authentication, and then that would load the—and then that would try to mount the next thing, which would be stuck loading for its data. So, like, really cascading effects like that by front-loading these data fetches and moving them to the server-side using get-props, right, get-server-props where possible. And also, yeah, and reducing the amount of data by removing kind of duplicates and aggregating queries. This is also GraphQL, as I mentioned, aggregating the queries into one compound one that then could be using a central store model, kind of like Redux, where the client islands could fetch from the service first or request it from the service. So that's what I did there. So I did that myself.

